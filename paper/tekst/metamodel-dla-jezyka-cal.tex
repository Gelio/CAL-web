\chapter{Metamodel dla języka CAL}

Aby otrzymać graficzny edytor modeli wykorzystując \emph{Sirius Web} należy
najpierw zaprojektować metamodel \gls{EMF} opisujący strukturę modeli oraz ich
reprezentację graficzną, która później będzie możliwa do modyfikacji prze
użytkowników. W tym rozdziale
zostanie omówiony język \acrfull{CAL} służący do opisu obliczeń w systemie
\emph{BalticLSC}, a~następnie omówiony zostanie przygotowany metamodel
\gls{EMF}.

\section{Język opisu obliczeń w BalticLSC}

Obliczenia rozproszone wykonywane przez system \emph{BalticLSC} są zapisywane w
formie \emph{aplikacji obliczeniowej} (\emph{computation application})
korzystajac ze składni języka \acrfull{CAL} przygotowanego dla tego właśnie
systemu.

Podstawowym obiektem, który wysyła (wyjście)
lub odbiera (wejście) dane, jest \emph{port}. Jest on reprezentowany za pomocą
ikony kwadratu ze strzałką skierowaną w prawą stronę. Aplikacja obliczeniowa
składa
się z modułów obliczeniowych posiadających swoje porty, portów samej aplikacji
obliczeniowej, oraz połączeń między tymi portami. Grot połączenia wskazuje
kierunek przepływu danych.
Porty aplikacji obliczeniowej są zaznaczone na
diagramie ikoną portu (strzałką skierowaną w prawo) z pogrubioną
jedną z krawędzi ikony --- lewą dla wejścia, prawą dla wyjścia.

Porty modułów oraz aplikacji obliczeniowych mają różne ikony, które
są ustalane na~podstawie ich właściwości. Są dwa kryteria wpływające na ikonę:

\begin{itemize}
	\item różne krotności danych, które obsługuje port (\emph{data
		      multiplicity}):  dla pojedynczego pliku będzie to~pojedyncza strzałka, a dla katalogu --- wiele strzałek,
	\item różną liczbę pakietów przyjmowanych lub wysyłanych danych (\emph{token
		      multiplicity}, czy oczekuje pojedynczego zestawu danych wejściowych, czy moduł obsłuży kolejne zestawy danych wysyłane po chwili bez ponownego uruchomienia).
\end{itemize}

Moduł obliczeniowy rozpoczyna obliczenia dopiero gdy na każdym jego wejściu
znajdują się dane.

Przykładowe aplikacje obliczeniowe zostały przedstawione na
rysunkach~\ref{rys:sekwencyjna-aplikacja-obliczeniowa}
i~\ref{rys:mozliwa-do-zrownoleglenia-aplikacja-obliczeniowa}.
Pierwsza z nich (rysunek~\ref{rys:sekwencyjna-aplikacja-obliczeniowa}) jest
aplikacją, w której obliczenia mogą zostać wykonane
wyłącznie sekwencyjnie, ponieważ dane przepływają sekwencyjnie od wejścia
kolejno przez moduły nazwane \texttt{VideoToFrames}, \texttt{Face Detector},
\texttt{Blur Module}, \texttt{Blur module}, aż w końcu trafiają do wyjścia.
Inna jest struktura aplikacji na
rysunku~\ref{rys:mozliwa-do-zrownoleglenia-aplikacja-obliczeniowa}. Tam
przepływ danych rozdziela się~po~module obliczeniowym \texttt{Pdf page
	splitter} i obliczenie modułów \texttt{OCT Tesseract Tess 0.1} oraz
\texttt{OCR Tesseract LSTM 0.1} może zostać wykonane równolegle, być może
przez różne węzły obliczeniowe. Ich wyniki trafią później do modułu \texttt{Pdf
	data joiner 0.1} i przejdą dalej przez pozostałe moduły w sposób
sekwencyjny.

\begin{figure}[!ht]
	\centering

	\includegraphics[width=0.95\linewidth]{./images/balticlsc-example-diagram.png}
	\caption{Aplikacja obliczeniowa w BalticLSC z obliczeniami
		sekwencyjnymi.}\label{rys:sekwencyjna-aplikacja-obliczeniowa}
\end{figure}

% \begin{noindent}
\begin{figure}[!ht]
	\centering

	\includegraphics[width=0.99\linewidth]{./images/balticlsc-concurrent-application-example.png}
	\caption{Aplikacja obliczeniowa w BalticLSC z możliwością
		zrównoleglenia obliczeń.}\label{rys:mozliwa-do-zrownoleglenia-aplikacja-obliczeniowa}
\end{figure}
% \end{noindent}

\section{Stworzony metamodel EMF dla języka CAL}

Przygotowany metamodel \gls{EMF} dla języka \gls{CAL} widoczny jest na
rysunku~\ref{rys:cal-emf-metamodel}. Bazuje on~na metamodelu
opracowanym w ramach projektu BalticLSC~\cite{cal-metamodel}, który widoczny
jest na~rysunku~\ref{rys:cal-metamodel-balticlsc}.
Na potrzeby edytora diagramów nie są potrzebne wszystkie elementy oryginalnego
metamodelu. Niektóre klasy i właściwości zostały pominięte, ponieważ nie były
istotne z~perspektywy edycji diagramu.

\begin{figure}[!hb]
	\centering

	\includegraphics[width=0.92\linewidth]{./images/cal-emf-metamodel.pdf}
	\caption{Metamodel EMF języka CAL przygotowany w ramach tej
		pracy.}\label{rys:cal-emf-metamodel}
\end{figure}

% TODO: bring the figure closer to the text that references it
\begin{figure}[!hb]
	\centering

	\includegraphics[width=0.92\linewidth]{./images/cal-metamodel-balticlsc.png}
	\caption{Metamodel języka CAL używany w projekcie
		BalticLSC\@.}\label{rys:cal-metamodel-balticlsc}

	\medskip
	{\small Źródło:
		\url{https://www.balticlsc.eu/model/index.htm?goto=4:2:404}}
\end{figure}

Model w EMF jest strukturą drzewiastą. Korzeniem drzewa jest obiekt typu
\texttt{ComputationApplicationRelease}, ktory odpowiada całemu diagramowi. Nie
ma on~własnych właściwości. Zawiera on w sobie natomiast 4 typy obiektów:

\begin{itemize}
	\item \texttt{ComputationUnitRelease} --- są to obiekty odpowiadające
	      rodzajom modułów obliczeniowych dostępnych w systemie BalticLSC i opisują ich właściwości.

	      Oprócz informacji o nazwie i wersji modułu zawierają w sobie obiekty \texttt{DeclaredDataPin} dziedziczące z \texttt{DataPin}, które opisują porty tego modułu obliczeniowego.

	      Obiekty te nie są wyświetlane na diagramie (nie występują w wizualnej reprezentacji modelu). Można je zobaczyć jedynie w drzewie obiektów modelu.

	\item \texttt{UnitCall} --- wywołania dostępnych modułów
	      obliczeniowych. Każdy dostępny moduł obliczeniowy może zostać wywołany dowolną liczbę razy. Każde wywołanie to osobny obiekt \texttt{UnitCall} ze wskazaniem modułu, który ma zostać wywołany, a także z obiektami \texttt{ComputedDataPin}, które reprezentują porty tego modułu.

	      Taka reprezentacja pozwala na zapisanie szczegółów dotyczących dostępnych modułow obliczeniowych wyłącznie raz w modelu, a później wskazywaniu tych elementów w~każdym z wywołań modułu.

	      Rozwiązanie to ma jednak pewne ograniczenie --- aby oznaczyć wywołanie modułu za~pomocą obiektu \texttt{UnitCall}, należy najpierw stworzyć obiekt \texttt{ComputationUnitRelease} i~dodać odpowiednie \texttt{DeclaredDataPin}. Można wywołać jedynie moduły, które są~zapisane w metamodelu. Sam metamodel nie ma możliwości pobrania informacji o~dostępnych modułach obliczeniowych z systemu BalticLSC, więc w podstawowej wersji metamodelu to użytkownik musi samemu dodać dostępne moduły w metamodelu.

	      Na diagramie obiekty te są reprezentowane jako prostokąty ze swoimi portami umieszczonymi na krawędziach. Wewnątrz prostokąta znajduje się etykieta zawierająca nazwę umożliwiającą wyróżnienie tego konkretnego wywołania modułu, oraz nazwę i wersję wydania wywolywanego modułu.

	\item \texttt{ApplicationDataPin} --- porty aplikacji obliczeniowej
	      opisywanej przez ten model. Są~to~wejścia i wyjścia z diagramu. Właściwości portu są dziedziczone z klasy \texttt{DataPin}.

	      Z uwagi na fakt, że te porty będą łączone z innymi portami, klasa ta dziedziczy z klasy \texttt{ConnectableDataPin}.

	      Na diagramie obiekty te reprezentowane są jako prostokąty z ikoną strzałki w prawo z~pogrubionym prawym lub lewym jej bokiem.

	\item \texttt{DataFlow} --- połączenia między portami
	      (\texttt{ConnectableDataPin}) umieszczonymi na~wywołaniach węzłów
	      obliczeniowych (\texttt{ComputedDataPin} na \texttt{UnitCall}) lub portami aplikacji obliczeniowej (\texttt{ApplicationDataPin}).

	      Na diagramie obiekty te reprezentowane są jako krawędzie z grotem wskazującym kierunek przepływu danych.
\end{itemize}

Przykładowy diagram reprezentujący model EMF języka CAL wyświetlony w programie
\emph{Sirius Desktop} został przedstawione na
rysunku~\ref{rys:sirius-desktop-cal-example-model}.

% \begin{noindent}
\begin{figure}[!hb]
	\centering

	\includegraphics[width=0.95\linewidth]{./images/sirius-desktop-cal-example-model.png}
	\caption{Przykładowy diagram reprezentujący model EMF języka CAL w
		\emph{Sirius Desktop}.}\label{rys:sirius-desktop-cal-example-model}
\end{figure}
% \end{noindent}

Oprócz podstawowej struktury metamodelu oraz jego reprezentacji w formie
diagramu zostały do niego dodane dodatkowe funkcjonalności. Zostały one opisane
w kolejnych sekcjach.

\subsection{Warunkowa zmiana stylu elementów}

% \begin{noindent}
Użytkownik może wywnioskować dodatkowe informacje z diagramu jeżeli jego wygląd
będzie zależał od właściwości elementów modelu. Takie rozwiązanie zastosowano
dla dwóch elementów metamodelu dzięki wykorzystaniu \emph{Style
	Customizations}~\cite{sirius-desktop-documentation-style-customizations}
w \gls{EMF}.
% \end{noindent}
Funkcjonalność ta pozwala na wskazanie za pomocą języka \gls{AQL} w jakich
sytuacjach styl elementu powinien zostać zmieniony, a następnie wskazać które
właściwości powinny ulec zmianie oraz ich nowe wartości.

Pierwszym styl warunkowy został użyty dla portów w metamodelu. Porty
(\texttt{DataPin}) zmieniają ikonę na podstawie swoich krotności danych oraz
paczek danych (odpowiednio \emph{data multiplicity} i \emph{token
	multiplicity}).

Z uwagi na fakt, że oba parametry mogą mieć jedną z 2 wartości,
co daje w sumie 4~możliwości, w klasie \texttt{Services} metamodelu stworzono
metodę w języku Java, która zwraca nazwę odpowiedniej ikony.
Dzięki możliwości wykorzystania języka programowania osiągnięto
zamierzony efekt za pomocą jednego stylu warunkowego, a nie 4 różnych
styli dla 4 możliwości. Kod metody zwracającej nazwę ikony dla portu
został przedstawiony w listingu~\ref{lst:getDataPinIconPath-method}.

\begin{lstlisting}[language=Java,
    caption={Methoda zwracająca nazwę ikony dla portu.},
    label={lst:getDataPinIconPath-method}]
public String getDataPinIconPath(EObject self) {
  if (!(self instanceof DataPin)) {
    return null;
  }

  var dataPin = (DataPin) self;
  var dataPart = dataPin.getDataMultiplicity() == Multiplicity.SINGLE ? "single-data" : "multiple-data";
  var tokenPart = dataPin.getTokenMultiplicity() == Multiplicity.SINGLE ? "single-token" : "multiple-tokens";

  return dataPart + "-" + tokenPart + ".png";
}
\end{lstlisting}

Dla portów całej aplikacji obliczeniowej (\texttt{ApplicationDataPin} dla
\texttt{ComputationApplicationRelease}) styl warunkowy był rozszerzeniem tego
dla portów modułów obliczeniowych. Oprócz brania pod uwagę kroności danych oraz
paczek danych, w tym stylu znaczenie ma ponadto kierunek portu. Porty wejściowe
mają pogrubiony pasek z lewej strony, a porty wyjściowe z prawej. Dla tych
portów występują 3 cechy od których zależy ikona, co oznacza 8 możliwości.
Dzięki wykorzystaniu metody z listingu~\ref{lst:getDataPinIconPath-method} oraz
języka \gls{AQL} ta funkcjonalność została zrealizowana za pomocą jednego stylu
warunkowego, zamiast 8 styli dla 8 różnych waruantow.

Drugim wykorzystanym rodzajem styli warunkowych jest zmiana koloru obramowania
portów na krawędziach modułów obliczeniowych (\texttt{ComputedDataPin}) w
zależności od~kierunku przepływu danych. Porty wejściowe (\emph{required}) mają
ramkę koloru fioletowego, a~porty wyjściowe (\emph{provided}) mają ramkę koloru
pomarańczowego. Ta funkcjonalność została zaimplementowana za pomocą jednego
stylu warunkowego.

Wyniki działania obu rodzajów styli warunkowych widoczne są na
rysunku~\ref{rys:sirius-desktop-cal-example-model}.

\subsection{Narzędzia edytora diagramów}

W metamodelach \gls{EMF} można zdefiniować narzędzia wspomagające i ułatwiające
edycję modeli, a także pomagające uniknąć
błędów~\cite{sirius-desktop-documentation-tools}. Również do metamodelu języka
CAL dodano takie narzędzia, które zostaną omówione w tej sekcji.

Pierwszą grupą narzędzi dodanych do metamodelu EMF języka CAL są narzędzia
automatyzujące pracę użytkownika, aby ten nie musiał manualnie wykonywać
niektórych czynności, a~jednocześnie aby w modelu nie znajdowały się nieużywane
elementy.

Jednym z takich narzędzi jest automatyczne usuwanie połączeń między portami
w~momencie, gdy ten port zostaje usunięty. W przypadku portów aplikacji
obliczeniowej (\texttt{ApplicationDataPin}) narzędzie to zastępuje zwykłą
operację usunięcia. Dla portów wywołania modułu obliczeniowego
(\texttt{ComputedDataPin}), narzędzie to uruchamiane jest podczas usuwania tego
modułu obliczeniowego. Dzięki temu narzędziu w modelu nie pozostają połączenia
zakończone jedynie z jednej strony.

Drugim z narzędzi automatyzujących pracę jest automatyczne zarządzanie
portami wywołania modułu obliczeniowego (\texttt{ComputedDataPin}) w~momencie
wskazania lub zmiany który moduł obliczeniowy ma zostać wywołany. Zmiana
atrybutu \texttt{unit} obiektu \texttt{UnitCall} usuwa aktualnie powiązane z
nim porty (o ile jakieś istniały) i tworzy nowe na podstawie definicji modułu
obliczeniowego (\texttt{ComputationUnitRelease}) zapisanej w metamodelu,
a~także jego zdeklarowanych portów \texttt{DeclaredDataPin}. Stworzone porty
mają
automatycznie ustawione odwołania na właściwe deklaracje portów.
Wykorzystanie tego narzędzia zostało przedstawione na
rysunku~\ref{rys:sirius-desktop-change-unit-to-call}.
Dzięki temu narzędziu użytkownik nie musi samemu usuwać starych portów
i~tworzyć nowych podczas zmiany wywoływanego modułu. Przyśpiesza to~pracę z
metamodelem i pomaga uniknąć błędów.

% \begin{noindent}
\begin{figure}
	\centering
	\begin{subfigure}{.3\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{./images/sirius-desktop-empty-unit-call.png}
		\caption{Nowo utworzone wywołanie modułu obliczeniowego.}\label{ref:sirius-desktop-empty-unit-call}
    \medskip
    {\small To wywolanie nie ma wskazanego modułu, które ma wywołać, stąd
      druga linia etykiety jest pusta.}
    \vspace{50pt}
	\end{subfigure}
	\begin{subfigure}{.3\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{./images/sirius-desktop-change-unit-to-call-before.png}
		\caption{Wywołanie modułu obliczeniowego po wskazaniu modułu do wywołania.}\label{
      rys:sirius-desktop-change-unit-to-call-before}
    \medskip
    {\small Porty zostały automatycznie utworzone zgodnie z deklaracją modułu
      \emph{Bounding Labels}.}
    \medskip
	\end{subfigure}
	\begin{subfigure}{.3\textwidth}
		\centering
		\includegraphics[width=.99\linewidth]{./images/sirius-desktop-change-unit-to-call-after.png}
		\caption{Wywołanie modułu obliczeniowego po ponownym wskazaniu modułu do wywołania.}\label{
      rys:sirius-desktop-change-unit-to-call-after}
    \medskip
    {\small Poprzednie porty zostały usunięte, a na ich miejsce zostały
      utworzone nowe, bazując na zdeklarowanych portach modułu \emph{Object
      Identification}.}
	\end{subfigure}

	\caption{Demonstracja działania narzędzia zarządzającego portami wywołań
    modułów obliczeniowych.}\label{rys:sirius-desktop-change-unit-to-call}
\end{figure}
% \end{noindent}

Inną grupą narzędzi są narzędzia pomagające w przestrzeganiu poprawności
modelu. Do~tej~grupy można zaliczyć kilka narzędzi dotyczących tworzenia lub
modyfikacji połączeń między portami. Dane mogą przepływać jedynie od portów
wyjściowych do portów wejściowych. Ponadto, niemożliwe jest połączenie portów
na tym samym wywołaniu modułu obliczeniowego. Oba te wymagania mogą być
egzekwowane w modelu za pomocą narzędzi do tworzenia połączeń (\emph{Edge
	Creation}) oraz do zmiany połączenia (\emph{Reconnect Edge}). Pierwsze
z nich za
pomocą warunków \emph{Connection Start Precondition} oraz
\emph{Connection Complete Precondition} ustalających czy połączenie może zostać
rozpoczęte lub zakończone w~danym elemencie pozwala zabronić stworzenia
połączenia. Drugie z nich za pomocą warunki \emph{Precondition} ustala kiedy
zmiana jednego z końców połączenia jest możliwa.

Drugim z narzędzi w grupie pomagających w przestrzeganiu poprawności jest
narzędzie uniemożliwiające usuwanie portów wywołań modułów obliczeniowych
(\texttt{ComputedDataPin}). Są one tworzone i usuwane automatycznie podczas
wskazania modułu do wywołania i~niepoprawnym byłoby gdyby użytkownik mógł
tworzyć lub usuwać je samemu, ponieważ licza portów mogłaby się wtedy nie
zgadzać z liczbą zadeklarowanych portów w tym module obliczeniowym.

Innym typem narzędzi są narzędzia ułatwiające tworzenie elementów modelu.
Są~3~proste narzędzia umieszczających element w modelu: dla portu wejściowego i
wyjściowego aplikacji, a także dla pustego wywołania modułu obliczeniowego, dla
którego należy później wskazać moduł, który ma wywołać. Bardziej skomplikowanym
narzędziem jest narzędzie pozwalające na dodanie do modelu wywołania modułu
obliczeniowego, które pokazuje okno dialogowe pozwalające wybrać moduł oraz
wskazać nazwę dodawanego obiektu. Wykorzystuje ono~możliwości \emph{Sirius
	Desktop} do tworzenia okien dialogowych (zarówno jednorazowych
jak~i~takich
składających się z wielu kroków)~\cite{sirius-desktop-documentation-tools} i
pozwala na dostarczeniu użytkownikowi
bardziej interaktywnego i przyjemniejszego doświadczenia. Okno dialogowe
pokazujące się po wybraniu
tego narzędzia jest przedstawione na
rysunku~\ref{rys:sirius-desktop-create-unit-call-tool}.

% \begin{noindent}
\begin{figure}[!hb]
	\centering

	\includegraphics[width=0.95\linewidth]{./images/sirius-desktop-create-unit-call-tool.png}
	\caption{Narzędzie do interaktywnego tworzenia nowego wywołania modułu
		obliczeniowego w \emph{Sirius Desktop}.}\label{rys:sirius-desktop-create-unit-call-tool}
\end{figure}
% \end{noindent}

Narzędzia te uruchamiają się jedynie, gdy zmiana w modelu zostanie wykonana
poprzez edycję diagramu lub właściwości już istniejącego elementu. Poprzez
bezpośrednią edycję drzewa modelu narzędzia powiązane z metamodelem są
pomijane, przez co można doprowadzić do sytuacji, że model nie będzie poprawny
semantycznie. Przykładem operacji pomijającej narzędzia jest usunięcie portu
aplikacji obliczeniowej (\texttt{ApplicationDataPin}) bezpośrednio z~drzewa
modelu. Jeżeli miała ona połączenie (\texttt{DataFlow}), nie zostanie ono
automatycznie usunięte (narzędzie, które je usuwa nie zostanie uruchomione), co
prowadzi do istnienia w~modelu połączenia, którego jedynie jeden koniec jest
poprawnie ustawiony. Takie sytuacje natomiast są wykrywane przez reguły
walidacji strukturalnej metamodelu (połączenie musi mieć poprawne oba końce).

\subsection{Reguły walidacyjne powiązane z
	metamodelem}\label{sec:regulky-walidacyjne-metamodel}

Omówienie \textit{semantic validation rule} z pliku \texttt{*.odesign}, które
działają w Sirius Desktop.

\subsection{Testy metamodelu}

Omówienie dodanych testów jednostkowych modelu (głównie dotyczy automatycznego
zarządzania \texttt{ComputedDataPin} w zależnosci od
\texttt{ComputationUnitRelease} dla konkretnego \texttt{UnitCall}).
